# data file for the Fltk User Interface Designer (fluid)
version 1.0304
use_FL_COMMAND
header_name {.hpp}
code_name {.cpp}
decl {\#include "editor.hpp"} {private global
}

decl {\#include "editor_ilib.hpp"} {private global
}

decl {\#include "ilib_glue.h"} {private global
}

decl {\#include <FL/Fl_File_Chooser.H>} {private global
}

decl {\#include <FL/Fl_PNG_Image.H>} {private global
}

decl {\#include <FL/fl_ask.H>} {private global
}

decl {struct BottleItem;} {public global
}

decl {Fl_Image *item_icon_image = NULL;} {private local
}

Function {SaveChanges(CinEdit::EnumSystem sys)} {open private return_type bool
} {
  code {const int flags = Fl_File_Chooser::CREATE|Fl_File_Chooser::SINGLE;
static Fl_File_Chooser create_chooser("./", "", flags, "");

switch(sys){
    case CinEdit::eItemSystem:
        {
            CinEdit::ilib& ilib = CinEdit::GetIlib();
            if(ilib.getPath().empty()){
               create_chooser.label("Create New Item Library");
               create_chooser.filter("Item Library (*.ilib)");
               create_chooser.show();
               while(create_chooser.shown())
                   Fl::wait();
               if(create_chooser.count() > 0)
                   ilib.setPath(create_chooser.value(1));
               else
                   return false;
           }
           ilib.save();
       }
    break;
    case CinEdit::eCellSystem: break;
    case CinEdit::eNUM_SYSTEMS: break;
}

return true;} {}
}

Function {AskSaveChanges(CinEdit::EnumSystem sys)} {open private return_type bool
} {
  code {const int flags = Fl_File_Chooser::CREATE|Fl_File_Chooser::SINGLE;
static Fl_File_Chooser chooser("./", "", flags, "");

const char warning[] = "Any unsaved changes will be lost. Would you like to save all changes?";
if(CinEdit::GetUnsavedChanges(sys)){
    const int choice = fl_choice(warning, "Don't Save", "Save", "Cancel");
    if(choice == 2)
        return false;
    if(choice == 1)
        SaveChanges(sys);
}

return true;} {}
}

Function {make_editor_window()} {open
} {
  code {if(CinEdit::GetCellType() == CinEdit::eExterior){
    menu_interior_toggle->flags &= ~FL_MENU_VALUE;
    menu_exterior_toggle->flags |= FL_MENU_VALUE;
}
else{
    menu_interior_toggle->flags |= FL_MENU_VALUE;
    menu_exterior_toggle->flags &= ~FL_MENU_VALUE;
}} {}
  Fl_Window {} {
    label {Cinnabar Editor} open
    xywh {87 155 680 525} type Double box THIN_UP_BOX align 80 hide
  } {
    Fl_Menu_Bar {} {open
      xywh {-5 0 710 25} selection_color 133
    } {
      Submenu {} {
        label {&File} open
        xywh {0 0 70 20}
      } {
        MenuItem {} {
          label {&New}
          xywh {15 15 36 20} shortcut 0x4006e
        }
        Submenu {} {
          label {Cr&eate} open
          xywh {0 0 70 20}
        } {
          MenuItem {} {
            label {New &Cell}
            xywh {5 5 36 20} shortcut 0x50063
          }
          MenuItem {} {
            label {New &Item Lib}
            callback {// Do all updates first thing.
const int n = item_browser->value();
if(n > 0)
    UpdateItemFromInfoFrame(n - 1);

const Fl_Widget *const selected_tab = editor_tabs->value();

if(selected_tab == item_tab){
    if(!AskSaveChanges(CinEdit::eItemSystem))
        return;
}}
            xywh {15 15 36 20} shortcut 0x50069
          }
        }
        MenuItem {} {
          label {&Open}
          callback {// Do all updates first thing.
const int n = item_browser->value();
if(n > 0)
    UpdateItemFromInfoFrame(n - 1);

const Fl_Widget *const selected_tab = editor_tabs->value();
const int flags = Fl_File_Chooser::SINGLE;
static Fl_File_Chooser chooser("./", "", flags, "");

if(selected_tab == item_tab){
    if(!AskSaveChanges(CinEdit::eItemSystem))
        return;
    CinEdit::ilib &ilib = CinEdit::GetIlib();
    chooser.label("Open Item Library");
    chooser.filter("Item Library (*.ilib)");
    chooser.show();
    while(chooser.shown())
        Fl::wait();
    if(chooser.count() > 0){
        ilib.load(chooser.value(1));
        const unsigned size = ilib.getNumItems();
        const BottleItem *const items = ilib.getItems();
        char staticbuffer[0x100], *dynbuffer = NULL;
        unsigned dynbuffer_capacity = 0;
        for(unsigned i = 0; i < size; i++){
            char *buffer = NULL;
            if(items[i].name.len + 1 < sizeof(staticbuffer)){
                buffer = staticbuffer;
            }
            else{
                if(dynbuffer_capacity < items[i].name.len){
                    if(dynbuffer_capacity == 0)
                        dynbuffer_capacity = 1;
                    while(dynbuffer_capacity < items[i].name.len + 1)
                       dynbuffer_capacity <<= 1;
                    dynbuffer = (char*)realloc(dynbuffer, dynbuffer_capacity);
                }
                buffer = dynbuffer;
            }
            memcpy(buffer, items[i].name.str, items[i].name.len);
            buffer[items[i].name.len] = '\\0';
            item_browser->add(buffer, (void*)(items + i));
        }
        item_browser->redraw();
        free(dynbuffer);
    }
}} selected
          xywh {10 10 36 20} shortcut 0x4006f
        }
        MenuItem save_menu_item {
          label {&Save}
          callback {// Do all updates first thing.
const int n = item_browser->value();
if(n > 0)
    UpdateItemFromInfoFrame(n - 1);

const Fl_Widget *const selected_tab = editor_tabs->value();
if(selected_tab == item_tab)
    SaveChanges(CinEdit::eItemSystem);
else if(selected_tab == cell_tab)
    SaveChanges(CinEdit::eCellSystem);}
          private xywh {20 20 36 20} shortcut 0x40073 deactivate
        }
        MenuItem save_as_menu_item {
          label {Save As}
          private xywh {30 30 36 20} shortcut 0x50073 deactivate divider
        }
        MenuItem {} {
          label {&Export...}
          xywh {0 0 36 20} shortcut 0x50065 deactivate
        }
        MenuItem {} {
          label {&Import...}
          xywh {10 10 36 20} shortcut 0x50069 deactivate divider
        }
        MenuItem {} {
          label {&Quit}
          callback {const char *const warning = "Are you sure you want to quit? Any unsaved changes will be lost.";
if(!CinEdit::GetUnsavedChanges() || 
    fl_choice(warning, "Quit", "Cancel", NULL) == 0)
    exit(EXIT_SUCCESS);}
          xywh {20 20 36 20} shortcut 0x40071
        }
      }
      Submenu {} {
        label {&Edit} open
        xywh {0 0 70 20}
      } {
        MenuItem {} {
          label {&Undo}
          xywh {10 10 36 20} shortcut 0x4007a
        }
        MenuItem {} {
          label {&Redo}
          xywh {20 20 36 20} shortcut 0x40079 divider
        }
        MenuItem {} {
          label {C&ut}
          xywh {30 30 36 20} shortcut 0x40078
        }
        MenuItem {} {
          label {&Copy}
          xywh {40 40 36 20} shortcut 0x40063
        }
        MenuItem {} {
          label {&Paste}
          xywh {50 50 36 20} shortcut 0x40076
        }
        MenuItem {} {
          label {&Duplicate}
          xywh {60 60 36 20} shortcut 0x40064 divider
        }
        MenuItem {} {
          label {&Find}
          xywh {70 70 36 20} shortcut 0x40066 divider
        }
        MenuItem {} {
          label {&Preferences}
          xywh {70 70 36 20} shortcut 0x40070
        }
      }
      Submenu {} {
        label Cell open
        xywh {0 0 70 20}
      } {
        MenuItem menu_interior_toggle {
          label Interior
          callback {CinEdit::SetCellType(CinEdit::eInterior);}
          private xywh {0 0 36 20} type Radio
        }
        MenuItem menu_exterior_toggle {
          label Exterior
          callback {CinEdit::SetCellType(CinEdit::eExterior);}
          private xywh {10 10 36 20} type Radio divider
        }
      }
      Submenu debug_submenu {
        label Debug open
        private xywh {0 0 70 20}
      } {
        MenuItem {} {
          label {Dump Item Library}
          callback {const CinEdit::ilib &ilib = CinEdit::GetIlib();
const unsigned size = ilib.getNumItems();
const BottleItem *const items = ilib.getItems();

for(unsigned i = 0; i < size; i++){
    fputs("Item ", stdout);
    fwrite(items[i].name.str, 1, items[i].name.len, stdout);
    printf(", type %i\\n", items[i].ItemType);
}}
          xywh {0 0 36 20}
        }
      }
    }
    Fl_Tabs editor_tabs {
      callback {if(editor_tabs->value() != cell_tab){
    save_menu_item->activate();
    save_as_menu_item->activate();
}
else{
    save_menu_item->deactivate();
    save_as_menu_item->deactivate();
}} open
      xywh {0 25 680 505} selection_color 133
    } {
      Fl_Group cell_tab {
        label Cell
        xywh {0 45 680 485} selection_color 133 hide
      } {
        Fl_Tabs cell_tabs {open
          xywh {5 50 300 470} selection_color 133
        } {
          Fl_Group heightmap_tab {
            label Heightmap open
            private xywh {5 75 300 445} hide
          } {
            Fl_File_Input {} {
              label {File:}
              xywh {50 81 205 34} selection_color 133
            }
            Fl_Button {} {
              label {...}
              xywh {255 90 45 25}
            }
            Fl_Box {} {
              label {Image...}
              xywh {50 124 205 172}
            }
          }
          Fl_Group statics_tab {
            label Statics open
            private xywh {5 75 300 445}
          } {
            Fl_Browser {} {
              label Statics
              xywh {10 95 290 395} selection_color 133 align 1
            }
            Fl_Button {} {
              label {Add...}
              xywh {230 495 70 20}
            }
            Fl_Button {} {
              label Remove
              xywh {155 495 70 20}
            }
            Fl_Button {} {
              label Clear
              xywh {80 495 70 20}
            }
          }
          Fl_Group {} {
            label Triggers open
            xywh {5 75 300 445} hide
          } {
            Fl_Browser {} {
              label Triggers
              xywh {10 95 290 395} selection_color 133 align 1
            }
            Fl_Button {} {
              label {Add...}
              xywh {230 495 70 20}
            }
            Fl_Button {} {
              label Remove
              xywh {155 495 70 20}
            }
            Fl_Button {} {
              label Clear
              xywh {80 495 70 20}
            }
          }
          Fl_Group {} {
            label Libraries open
            xywh {5 70 300 450} hide
          } {
            Fl_Tile {} {open
              xywh {5 75 300 445}
            } {
              Fl_Box library_tile_resize_limiter {
                xywh {24 130 35 335} resizable
              }
              Fl_Group {} {open
                xywh {5 75 300 230} box THIN_UP_BOX
              } {
                Fl_Browser {} {
                  label {Item Libraries}
                  xywh {10 95 290 180} selection_color 133 align 1 resizable
                }
                Fl_Button {} {
                  label {Add...}
                  xywh {230 280 70 20}
                }
                Fl_Button {} {
                  label Remove
                  xywh {155 280 70 20}
                }
                Fl_Button {} {
                  label Clear
                  xywh {80 280 70 20}
                }
              }
              Fl_Group {} {open
                xywh {5 305 300 215} box THIN_UP_BOX
              } {
                Fl_Browser {} {
                  label {Character Libraries}
                  xywh {10 325 290 165} selection_color 133 align 1 resizable
                }
                Fl_Button {} {
                  label {Add...}
                  xywh {230 495 70 20}
                }
                Fl_Button {} {
                  label Clear
                  xywh {80 495 70 20}
                }
                Fl_Button {} {
                  label Remove
                  xywh {155 495 70 20}
                }
              }
            }
          }
        }
      }
      Fl_Group item_tab {
        label {Item Library} open
        xywh {0 50 680 475}
      } {
        Fl_Tile {} {open
          xywh {5 55 670 465} resizable
        } {
          Fl_Browser item_browser {
            callback {static int last_selected = 0;
const int line = item_browser->value();
if(last_selected != 0)
    UpdateItemFromInfoFrame(last_selected - 1);
last_selected = line;
if(line == 0)
    item_info_frame->deactivate();
else{
    item_info_frame->activate();
    const CinEdit::ilib &ilib = CinEdit::GetIlib();
    const BottleItem &item = ilib.getItems()[line-1];
    UpdateItemInfoFrameUI(item);
}}
            xywh {5 55 235 465} type Hold selection_color 133 when 3
          }
          Fl_Group {} {open
            xywh {240 55 435 465} box FLAT_BOX
          } {
            Fl_Group item_info_frame {open
              xywh {245 60 425 425} box ENGRAVED_BOX deactivate resizable
            } {
              Fl_Box {} {
                xywh {505 458 160 22} resizable
              }
              Fl_Choice item_type_choice {
                label Type open
                private xywh {290 70 115 20} down_box BORDER_BOX selection_color 133 when 1
              } {
                MenuItem armor_menu_item {
                  label Armor
                  callback {item_type_wizard->value(armor_wiz);
item_type_wizard->redraw();}
                  private xywh {0 0 36 20}
                }
                MenuItem weapon_menu_item {
                  label Weapon
                  callback {item_type_wizard->value(weapon_wiz);
item_type_wizard->redraw();}
                  private xywh {10 10 36 20}
                }
                MenuItem consumable_menu_item {
                  label Consumable
                  private xywh {20 20 36 20}
                }
                MenuItem junk_menu_item {
                  label Junk
                  private xywh {30 30 36 20}
                }
              }
              Fl_Wizard item_type_wizard {open
                xywh {255 120 405 155}
              } {
                Fl_Group armor_wiz {
                  label Armor open
                  xywh {255 120 405 155} box ENGRAVED_BOX hide
                } {
                  Fl_Choice armor_type_choice {
                    label {Armor Type} open
                    private xywh {365 130 115 20} down_box BORDER_BOX selection_color 133
                  } {
                    MenuItem helmet_menu_item {
                      label Helmet
                      private xywh {0 0 36 20}
                    }
                    MenuItem chestplate_menu_item {
                      label Chestplate
                      private xywh {10 10 36 20}
                    }
                    MenuItem boots_menu_item {
                      label Boots
                      private xywh {20 20 36 20}
                    }
                  }
                  Fl_Value_Input armor_defense_input {
                    label Defense
                    private xywh {365 160 115 20} selection_color 133 maximum 4096 step 1 value 1
                  }
                }
                Fl_Group weapon_wiz {
                  label Weapon open
                  xywh {255 120 405 155} box ENGRAVED_BOX
                } {
                  Fl_Choice weapon_type_choice {
                    label {Weapon Type} open
                    private xywh {365 130 115 20} down_box BORDER_BOX selection_color 133
                  } {
                    MenuItem sword_menu_item {
                      label Sword
                      private xywh {10 10 36 20}
                    }
                    MenuItem axe_menu_item {
                      label Axe
                      private xywh {20 20 36 20}
                    }
                  }
                  Fl_Value_Input weapon_attack_power_input {
                    label {Attack Power}
                    private xywh {365 160 115 20} selection_color 133 maximum 4096 step 1 value 1
                  }
                  Fl_Value_Input weapon_attack_speed_input {
                    label {Attack Speed}
                    private tooltip milliseconds xywh {365 190 115 20} selection_color 133 maximum 4096 step 1 value 1
                  }
                  Fl_Box {} {
                    xywh {490 224 160 36} resizable
                  }
                }
              }
              Fl_Value_Input item_value_input {
                label Value
                xywh {365 282 115 20} selection_color 133
              }
              Fl_Value_Input item_durability_input {
                label Durability
                xywh {365 310 115 20} selection_color 133
              }
              Fl_Value_Input item_weight_input {
                label Weight
                xywh {365 340 115 20} selection_color 133
              }
              Fl_Input item_name_input {
                label Name
                private xywh {455 70 205 20}
              }
              Fl_Box item_icon_image_box {
                xywh {532 282 128 128} box THIN_UP_BOX color 133 selection_color 133
              }
              Fl_Output item_icon_output {
                label {output:}
                xywh {310 371 170 24}
              }
              Fl_File_Input item_model_output {
                label Model
                xywh {310 416 170 34}
              }
              Fl_Button {} {
                label {...}
                callback {const char *const path =
	fl_file_chooser("Open Icon Image", "png (*.png)\\ttga (*.tga)", "", 1);
SetIconPathUI(path);}
                xywh {480 370 35 25}
              }
              Fl_Button {} {
                label {...}
                xywh {480 425 35 25}
              }
            }
            Fl_Button {} {
              label New
              callback {CinEdit::ilib &ilib = CinEdit::GetIlib();

BottleItem &item = ilib.append();
const char *name = fl_input("New item name", "item");

if(name == NULL)
    name = "item";

const unsigned len = strlen(name);
item.name.len = len;
item.name.str = (char*)malloc(len);
memcpy(item.name.str, name, len);

item_browser->add(name, &item);
item_browser->redraw();}
              xywh {245 490 105 25}
            }
            Fl_Button {} {
              label Delete
              xywh {360 490 105 25} deactivate
            }
          }
        }
      }
    }
  }
  code {\#ifdef NDEBUG
debug_submenu->hide();
\#endif} {}
}

Function {SetCellTypeUI(unsigned to_exterior)} {open C return_type void
} {
  code {if(to_exterior){
    heightmap_tab->activate();
    cell_tabs->redraw();
    menu_interior_toggle->flags &= ~FL_MENU_VALUE;
    menu_exterior_toggle->flags |= FL_MENU_VALUE;
}
else{
    heightmap_tab->deactivate();
    cell_tabs->redraw();
    menu_interior_toggle->flags |= FL_MENU_VALUE;
    menu_exterior_toggle->flags &= ~FL_MENU_VALUE;
}} {}
}

Function {UpdateItemBrowserUI()} {open return_type void
} {
  code {CinEdit::ilib &ilib = CinEdit::GetIlib();
const unsigned ilib_size = ilib.getNumItems();
BottleItem *const items = ilib.getItems();

item_browser->clear();
std::string name_buffer;
for(unsigned i = 0; i < ilib_size; i++){
    const BottleItem &item = items[i];
    name_buffer.assign(item.name.str, item.name.len);
    item_browser->add(name_buffer.c_str(), items + i);
}

item_browser->redraw();} {}
}

Function {UpdateItemInfoFrameUI(const BottleItem &item)} {open return_type void
} {
  code {COPY_OUT_BOTTLE_STRING(alloca, item.name, item_name_input->value);
COPY_OUT_BOTTLE_STRING(alloca, item.icon, item_icon_output->value);
if(false){
    const unsigned L_ = item.icon.len;
    char *const N_ = (char*)alloca(L_ + 1);
    memcpy(N_, item.icon.str, L_);
    N_[L_] = 0;
    item_icon_output->value(N_);
}
item_value_input->value(item.value);
item_durability_input->value(item.durability);
item_weight_input->value(item.weight);
SetIconPathUI(item.icon.str, item.icon.len, false);

switch(item.ItemType){
    case eArmor:
        item_type_choice->value(armor_menu_item);
        item_type_wizard->value(armor_wiz);
        armor_defense_input->value(item.ItemTypeData.armor.defense);
        switch(item.ItemTypeData.armor.atype){
            case eHelmet:
                armor_type_choice->value(helmet_menu_item);
                break;
            case eChestplate:
                armor_type_choice->value(chestplate_menu_item);
                break;
            case eBoots:
                armor_type_choice->value(boots_menu_item);
                break;
            default:
                armor_type_choice->value(0);
        }
        break;
    case eWeapon:
        item_type_choice->value(weapon_menu_item);
        item_type_wizard->value(weapon_wiz);
        weapon_attack_power_input->value(item.ItemTypeData.weapon.attack);
        weapon_attack_speed_input->value(item.ItemTypeData.weapon.speed);
        switch(item.ItemTypeData.weapon.wtype){
            case eSword:
                weapon_type_choice->value(sword_menu_item);
                break;
            case eAxe:
                weapon_type_choice->value(axe_menu_item);
                break;
            default:
                weapon_type_choice->value(0);
        }
        break;
    case eConsumable:
        item_type_choice->value(consumable_menu_item);
        //item_type_wizard->value(consumable_wiz);
        
        break;
    case eJunk:
        item_type_choice->value(junk_menu_item);
        //item_type_wizard->value(junk_wiz);
        
        break;
    default:
        item_type_choice->value(0);
}} {}
}

Function {UpdateItemFromInfoFrame(unsigned item_num)} {open return_type void
} {
  code {BottleItem &item = CinEdit::GetIlib().getItems()[item_num];

COPY_IN_BOTTLE_STRING(item.name, item_name_input->value());
COPY_IN_BOTTLE_STRING(item.icon, item_icon_output->value());

item.value = item_value_input->value();
item.durability = item_durability_input->value();
item.weight = item_weight_input->value();

CHOICE_TO_ENUM(item_type_choice, item.ItemType, Item);

switch(item.ItemType){
    default:
    case eArmor:
    	CHOICE_TO_ENUM(armor_type_choice, item.ItemTypeData.armor.atype, Armor);
        item.ItemTypeData.armor.defense = armor_defense_input->value();
        break;
    case eWeapon:
    	CHOICE_TO_ENUM(weapon_type_choice, item.ItemTypeData.weapon.wtype, Weapon);
        item.ItemTypeData.weapon.attack = weapon_attack_power_input->value();
        item.ItemTypeData.weapon.speed = weapon_attack_speed_input->value();
        break;
    case eConsumable:
        
        break;
    case eJunk:
        
        break;
}} {}
}

Function {SetIconPathUI(const char *path, unsigned len, bool nulled)} {open return_type void
} {
  code {if(path == NULL || *path == '\\0')
    return;

if(len < 4)
    return;

if(item_icon_image != NULL){
    item_icon_image_box->image(NULL);
    delete item_icon_image;
    item_icon_image = NULL;
}

if(memcmp(path + len - 4, ".png", 4) == 0 ||
    memcmp(path + len - 4, ".PNG", 4) == 0)
    item_icon_image = new Fl_PNG_Image(path);
else if(memcmp(path + len - 4, ".tga", 4) == 0 ||
    memcmp(path + len - 4, ".TGA", 4) == 0)
;//    item_icon_image = new Fl_PNG_Image(path);
else {
    item_icon_image = NULL;
    return;
}

if(nulled){
    item_icon_output->value(path);
}
else{
    char *const buffer = (char*)alloca(len + 1);
    memcpy(buffer, path, len);
    buffer[len] = '\\0';
    item_icon_output->value(buffer);
}
item_icon_image_box->image(item_icon_image);
item_icon_image_box->redraw();} {}
}

Function {SetIconPathUI(const char *path)} {open
} {
  code {if(path == NULL)
    SetIconPathUI("", 1, true);
else
    SetIconPathUI(path, strlen(path), true);} {}
}
